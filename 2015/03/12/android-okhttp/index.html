<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>OKHttp源码解析 | Frodo&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="因文章很快被人转载到一些其他网站，所以本人在此声明：转载请标明转载出处：http://frodoking.github.io/2015/03/12/android-okhttp/ 
Android为我们提供了两种HTTP交互的方式：HttpURLConnection 和 Apache HTTP Client，虽然两者都支持HTTPS，流的上传和下载，配置超时，IPv6和连接池，已足够满足我们各种H">
<meta property="og:type" content="article">
<meta property="og:title" content="OKHttp源码解析">
<meta property="og:url" content="http://frodoking.github.io/2015/03/12/android-okhttp/index.html">
<meta property="og:site_name" content="Frodo's Blog">
<meta property="og:description" content="因文章很快被人转载到一些其他网站，所以本人在此声明：转载请标明转载出处：http://frodoking.github.io/2015/03/12/android-okhttp/ 
Android为我们提供了两种HTTP交互的方式：HttpURLConnection 和 Apache HTTP Client，虽然两者都支持HTTPS，流的上传和下载，配置超时，IPv6和连接池，已足够满足我们各种H">
<meta property="og:image" content="http://frodoking.github.io/img/android/okhttp_instructure.png">
<meta property="og:image" content="http://frodoking.github.io/img/android/okhttp_request_process.png">
<meta property="og:image" content="http://frodoking.github.io/img/android/okhttp_okhttpclient_class.png">
<meta property="og:image" content="http://frodoking.github.io/img/android/okhttp_interceptor_running_stack.png">
<meta property="og:image" content="http://frodoking.github.io/img/android/okhttp_connection_lifecycle.png">
<meta property="og:image" content="http://frodoking.github.io/img/android/okhttp_connection_reset.png">
<meta property="og:updated_time" content="2015-09-14T06:47:57.698Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OKHttp源码解析">
<meta name="twitter:description" content="因文章很快被人转载到一些其他网站，所以本人在此声明：转载请标明转载出处：http://frodoking.github.io/2015/03/12/android-okhttp/ 
Android为我们提供了两种HTTP交互的方式：HttpURLConnection 和 Apache HTTP Client，虽然两者都支持HTTPS，流的上传和下载，配置超时，IPv6和连接池，已足够满足我们各种H">
<meta name="twitter:image" content="http://frodoking.github.io/img/android/okhttp_instructure.png">
  
    <link rel="alternative" href="/atom.xml" title="Frodo&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://avatars0.githubusercontent.com/u/7484982?v=3&amp;u=4e45871de440c2bd2302a5420358118d6a4950f7&amp;s=140" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Frodo</a></h1>
		</hgroup>

		
		<p class="header-subtitle">熟悉的歌谣里，藏着童话的影子。</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">文章列表</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/frodoking" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/u/2351718353" title="weibo">weibo</a>
					        
								<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
					        
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
								<a class="Sitemap" target="_blank" href="/sitemap.xml" title="Sitemap">Sitemap</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/android/" style="font-size: 20px;">Android</a> <a href="/tags/java/" style="font-size: 15px;">Java</a> <a href="/tags/tools/" style="font-size: 10px;">tools</a> <a href="/tags/music/" style="font-size: 10px;">音乐</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://zipperary.com/">Zipperra&#39;s Blog</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://litten.github.io/">Litten&#39;s Blog</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://scatterman.github.io/">Scatterman&#39;s Blog</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.danlew.net/">Dan Lew&#39;s Blog</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://diptech.sinaapp.com/">老苗的blog</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://codekk.com/open-source-project-analysis">codekk</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://androidweekly.net/">AndroidWeekly</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.google.com.cn">Google</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.baidu.com">Baidu</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Frodo</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="https://avatars0.githubusercontent.com/u/7484982?v=3&amp;u=4e45871de440c2bd2302a5420358118d6a4950f7&amp;s=140" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Frodo</h1>
			</hgroup>
			
			<p class="header-subtitle">熟悉的歌谣里，藏着童话的影子。</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">文章列表</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/frodoking" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/u/2351718353" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="Sitemap" target="_blank" href="/sitemap.xml" title="Sitemap">Sitemap</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-android-okhttp" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/03/12/android-okhttp/" class="article-date">
  	<time datetime="2015-03-12T09:00:50.000Z" itemprop="datePublished">Mar 12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      OKHttp源码解析
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">Java</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/programming/">编程</a><a class="article-category-link" href="/categories/programming/source/">源码</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>因文章很快被人转载到一些其他网站，所以本人在此声明：<br><strong>转载请标明转载出处：<a href="http://frodoking.github.io/2015/03/12/android-okhttp/">http://frodoking.github.io/2015/03/12/android-okhttp/</a> </strong></p>
<p>Android为我们提供了两种HTTP交互的方式：HttpURLConnection 和 Apache HTTP Client，虽然两者都支持HTTPS，流的上传和下载，配置超时，IPv6和连接池，已足够满足我们各种HTTP请求的需求。但更高效的使用HTTP可以让您的应用运行更快、更节省流量。而OkHttp库就是为此而生。</p>
<p>OkHttp是一个高效的HTTP库:</p>
<blockquote>
<ul>
<li>支持 SPDY ，共享同一个Socket来处理同一个服务器的所有请求</li>
<li>如果SPDY不可用，则通过连接池来减少请求延时</li>
<li>无缝的支持GZIP来减少数据流量</li>
<li>缓存响应数据来减少重复的网络请求</li>
</ul>
</blockquote>
<p>会从很多常用的连接问题中自动恢复。如果您的服务器配置了多个IP地址，当第一个IP连接失败的时候，OkHttp会自动尝试下一个IP。OkHttp还处理了代理服务器问题和SSL握手失败问题。</p>
<p>使用 OkHttp 无需重写您程序中的网络代码。OkHttp实现了几乎和java.net.HttpURLConnection一样的API。如果您用了 Apache HttpClient，则OkHttp也提供了一个对应的okhttp-apache 模块。</p>
<p>OKHttp源码位置<a href="https://github.com/square/okhttp" target="_blank" rel="external">https://github.com/square/okhttp</a><br><a id="more"></a></p>
<p>##使用</p>
<p>简单使用代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private final OkHttpClient client = new OkHttpClient();</span><br><span class="line"> </span><br><span class="line">public void run() throws Exception &#123;</span><br><span class="line">    Request request = new Request.Builder()</span><br><span class="line">        .url(&quot;https://api.github.com/repos/square/okhttp/issues&quot;)</span><br><span class="line">        .header(&quot;User-Agent&quot;, &quot;OkHttp Headers.java&quot;)</span><br><span class="line">        .addHeader(&quot;Accept&quot;, &quot;application/json; q=0.5&quot;)</span><br><span class="line">        .addHeader(&quot;Accept&quot;, &quot;application/vnd.github.v3+json&quot;)</span><br><span class="line">        .build();</span><br><span class="line"> </span><br><span class="line">    Response response = client.newCall(request).execute();</span><br><span class="line">    if (!response.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response);</span><br><span class="line"> </span><br><span class="line">    System.out.println(&quot;Server: &quot; + response.header(&quot;Server&quot;));</span><br><span class="line">    System.out.println(&quot;Date: &quot; + response.header(&quot;Date&quot;));</span><br><span class="line">    System.out.println(&quot;Vary: &quot; + response.headers(&quot;Vary&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里使用不做详细介绍，<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0106/2275.html" target="_blank" rel="external">推荐一篇关于OKHttp的详细使用教程</a>，下面转入源码的分析。</p>
<p>##总体设计<br><img src="http://frodoking.github.io/img/android/okhttp_instructure.png" alt="OKHttp总体设计图"><br>上面是OKHttp总体设计图，主要是通过Diapatcher不断从RequestQueue中取出请求（Call），根据是否已缓存调用Cache或Network这两类数据获取接口之一，从内存缓存或是服务器取得请求的数据。该引擎有同步和异步请求，同步请求通过Call.execute()直接返回当前的Response，而异步请求会把当前的请求Call.enqueue添加（AsyncCall）到请求队列中，并通过回调（Callback）的方式来获取最后结果。</p>
<p>接下来会介绍一些比较重要的类，另外一些基础IO方面的内容主要来之iohttp这个包。这些类的解释大部分来至文档介绍本身，所以在此不会翻译成中文，本人觉得英语原文更能准确表达它自身的作用。</p>
<p>##OKHttp中重要的类</p>
<p><strong>1.Route.java</strong><br>The concrete route used by a connection to reach an abstract origin server.<br>When creating a connection the client has many options:</p>
<blockquote>
<ul>
<li>HTTP proxy: a proxy server may be explicitly configured for the client. Otherwise the {@linkplain java.net.ProxySelector proxy selector} is used. It may return multiple proxies to attempt.</li>
<li>IP address: whether connecting directly to an origin server or a proxy, opening a socket requires an IP address. The DNS server may return multiple IP addresses to attempt.</li>
<li>TLS configuration: which cipher suites and TLS versions to attempt with the HTTPS connection.</li>
</ul>
</blockquote>
<p>Each route is a specific selection of these options.<br>其实就是对地址的一个封装类，但是很重要。</p>
<p><strong>2.Platform.java</strong><br>Access to platform-specific features.</p>
<blockquote>
<ul>
<li>Server name indication (SNI): Supported on Android 2.3+.</li>
<li>Session Tickets: Supported on Android 2.3+.</li>
<li>Android Traffic Stats (Socket Tagging): Supported on Android 4.0+.</li>
<li>ALPN (Application Layer Protocol Negotiation): Supported on Android 5.0+. The APIs were present in Android 4.4, but that implementation was unstable.</li>
</ul>
</blockquote>
<p>Supported on OpenJDK 7 and 8 (via the JettyALPN-boot library).<br>这个类主要是做平台适应性，针对Android2.3到5.0后的网络请求的适配支持。同时，在这个类中能看到针对不同平台，通过java反射不同的class是不一样的。</p>
<p><strong>3.Connnection.java</strong><br>The sockets and streams of an HTTP, HTTPS, or HTTPS+SPDY connection. May be used for multiple HTTP request/response exchanges. Connections may be direct to the origin server or via a proxy.<br>Typically instances of this class are created, connected and exercised automatically by the HTTP client. Applications may use this class to monitor HTTP connections as members of a ConnectionPool.<br>Do not confuse this class with the misnamed HttpURLConnection, which isn’t so much a connection as a single request/response exchange.<br>Modern TLS<br>There are tradeoffs when selecting which options to include when negotiating a secure connection to a remote host. Newer TLS options are quite useful:</p>
<blockquote>
<ul>
<li>Server Name Indication (SNI) enables one IP address to negotiate secure connections for multiple domain names.</li>
<li>Application Layer Protocol Negotiation (ALPN) enables the HTTPS port (443) to be used for different HTTP and SPDY protocols.</li>
</ul>
</blockquote>
<p>Unfortunately, older HTTPS servers refuse to connect when such options are presented. Rather than avoiding these options entirely, this class allows a connection to be attempted with modern options and then retried without them should the attempt fail.</p>
<p><strong>4.ConnnectionPool.java</strong><br>Manages reuse of HTTP and SPDY connections for reduced network latency. HTTP requests that share the same Address may share a Connection. This class implements the policy of which connections to keep open for future use.<br>The  system-wide default uses system properties for tuning parameters:</p>
<blockquote>
<ul>
<li>http.keepAlive true if HTTP and SPDY connections should be pooled at all. Default is true.</li>
<li>http.maxConnections maximum number of idle connections to each to keep in the pool. Default is 5.</li>
<li>http.keepAliveDuration Time in milliseconds to keep the connection alive in the pool before closing it. Default is 5 minutes. This property isn’t used by HttpURLConnection.</li>
</ul>
</blockquote>
<p>The default instance doesn’t adjust its configuration as system properties are changed. This assumes that the applications that set these parameters do so before making HTTP connections, and that this class is initialized lazily.</p>
<p><strong>5.Request.java</strong><br>An HTTP request. Instances of this class are immutable if their body is null or itself immutable.(Builder模式)</p>
<p><strong>6.Response.java</strong><br>An HTTP response. Instances of this class are not immutable: the response body is a one-shot value that may be consumed <strong>only once</strong>. All other properties are immutable.</p>
<p><strong>7.Call.java</strong><br>A call is a request that has been prepared for execution. A call can be canceled. As this object represents a single request/response pair (stream), <strong>it cannot be executed twice</strong>.</p>
<p><strong>8.Dispatcher.java</strong><br>Policy on when async requests are executed.</p>
<p>Each dispatcher uses an <strong>ExecutorService</strong> to run calls internally. If you supply your own executor, it should be able to run configured maximum number of calls concurrently.</p>
<p><strong>9.HttpEngine.java</strong><br>Handles <strong>a single HTTP request/response pair</strong>. Each HTTP engine follows this<br>lifecycle:</p>
<blockquote>
<ul>
<li>It is created.</li>
<li>The HTTP request message is sent with sendRequest(). Once the request is sent it is an error to modify the request headers. After sendRequest() has been called the request body can be written to if it exists.</li>
<li>The HTTP response message is read with readResponse(). After the response has been read the response headers and body can be read. All responses have a response body input stream, though in some instances this stream is empty.</li>
</ul>
</blockquote>
<p>The request and response may be served by the HTTP response <strong>cache</strong>, by the <strong>network</strong>, or by <strong>both</strong> in the event of a conditional GET.</p>
<p><strong>10.Internal.java</strong><br>Escalate internal APIs in {@code com.squareup.okhttp} so they can be used from OkHttp’s implementation packages. The only implementation of this interface is in {@link com.squareup.okhttp.OkHttpClient}.</p>
<p><strong>11.Cache.java</strong><br>Caches HTTP and HTTPS responses to the filesystem so they may be reused, saving time and bandwidth.</p>
<p><strong>Cache Optimization</strong><br>To measure cache effectiveness, this class tracks three statistics:</p>
<blockquote>
<ul>
<li>Request Count: the number of HTTP requests issued since this cache was created.</li>
<li>Network Count: the number of those requests that required network use.</li>
<li>Hit Count: the number of those requests whose responses were served by the cache.</li>
</ul>
</blockquote>
<p>Sometimes a request will result in a conditional cache hit. If the cache contains a stale copy of the response, the client will issue a conditional GET. The server will then send either the updated response if it has changed, or a short ‘not modified’ response if the client’s copy is still valid. Such responses increment both the network count and hit count.<br>The best way to improve the cache hit rate is by configuring the web server to return cacheable responses. Although this client honors all <a href="http://www.ietf.org/rfc/rfc2616.txt" target="_blank" rel="external">HTTP/1.1 (RFC 2068)</a> cache headers, it doesn’t cache partial responses.</p>
<p><strong>Force a Network Response</strong><br>In some situations, such as after a user clicks a ‘refresh’ button, it may be necessary to skip the cache, and fetch data directly from the server. To force a full refresh, add the {@code no-cache} directive:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection.addRequestProperty(&quot;Cache-Control&quot;, &quot;no-cache&quot;)</span><br></pre></td></tr></table></figure></p>
<p>If it is only necessary to force a cached response to be validated by the server, use the more efficient {@code max-age=0} instead:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection.addRequestProperty(&quot;Cache-Control&quot;, &quot;max-age=0&quot;);</span><br></pre></td></tr></table></figure></p>
<p><strong>Force a Cache Response</strong><br>Sometimes you’ll want to show resources if they are available immediately, but not otherwise. This can be used so your application can show something while waiting for the latest data to be downloaded. To restrict a request to locally-cached resources, add the {@code only-if-cached} directive:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">	connection.addRequestProperty(&quot;Cache-Control&quot;, &quot;only-if-cached&quot;);</span><br><span class="line">	InputStream cached = connection.getInputStream();</span><br><span class="line">	// the resource was cached! show it</span><br><span class="line">	&#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">	// the resource was not cached</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>This technique works even better in situations where a stale response is better than no response. To permit stale cached responses, use the {@code max-stale} directive with the maximum staleness in seconds:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int maxStale = 60 * 60 * 24 * 28; // tolerate 4-weeks stale</span><br><span class="line">connection.addRequestProperty(&quot;Cache-Control&quot;, &quot;max-stale=&quot; + maxStale);</span><br></pre></td></tr></table></figure></p>
<p><strong>12.OkHttpClient.java</strong><br>Configures and creates HTTP connections. Most applications can use a single OkHttpClient for all of their HTTP requests - benefiting from a shared response cache, thread pool, connection re-use, etc.</p>
<p>Instances of OkHttpClient are intended to be fully configured before they’re shared - once shared they should be treated as immutable and can safely be used to concurrently open new connections. If required, threads can call <strong>clone</strong> to make a shallow copy of the OkHttpClient that can be safely modified with further configuration changes.</p>
<p>##请求流程图<br>下面是关于OKHttp的请求流程图<br><img src="http://frodoking.github.io/img/android/okhttp_request_process.png" alt="OKHttp的请求流程图"></p>
<p>##详细类关系图<br>由于整个设计类图比较大，所以本人将从核心入口client、cache、interceptor、网络配置、连接池、平台适配性…这些方面来逐一进行分析源代码的设计。<br>下面是核心入口OkHttpClient的类设计图<br><img src="http://frodoking.github.io/img/android/okhttp_okhttpclient_class.png" alt="OkHttpClient的类设计图"><br>从OkHttpClient类的整体设计来看，它采用门面模式来。client知晓子模块的所有配置以及提供需要的参数。client会将所有从客户端发来的请求委派到相应的子系统去。<br>在该系统中，有多个子系统、类或者类的集合。例如上面的cache、连接以及连接池相关类的集合、网络配置相关类集合等等。每个子系统都可以被客户端直接调用，或者被门面角色调用。子系统并不知道门面的存在，对于子系统而言，门面仅仅是另外一个客户端而已。同时，OkHttpClient可以看作是整个框架的上下文。<br>通过类图，其实很明显反应了该框架的几大核心子系统；路由、连接协议、拦截器、代理、安全性认证、连接池以及网络适配。从client大大降低了开发者使用难度。同时非常明了的展示了该框架在所有需要的配置以及获取结果的方式。</p>
<p>在接下来的几个Section中将会结合子模块核心类的设计，从该框架的整体特性上来分析这些模块是如何实现各自功能。以及各个模块之间是如何相互配合来完成客户端各种复杂请求。</p>
<p>##同步与异步的实现<br>在发起请求时，整个框架主要通过Call来封装每一次的请求。同时Call持有OkHttpClient和一份HttpEngine。而每一次的同步或者异步请求都会有Dispatcher的参与，不同的是：</p>
<blockquote>
<ul>
<li>同步<br>Dispatcher会在同步执行任务队列中记录当前被执行过得任务Call，同时在当前线程中去执行Call的getResponseWithInterceptorChain（）方法，直接获取当前的返回数据Response；</li>
<li>异步<br>首先来说一下Dispatcher，Dispatcher内部实现了懒加载无边界限制的线程池方式，同时该线程池采用了SynchronousQueue这种阻塞队列。SynchronousQueue每个插入操作必须等待另一个线程的移除操作，同样任何一个移除操作都等待另一个线程的插入操作。因此此队列内部其 实没有任何一个元素，或者说容量是0，严格说并不是一种容器。由于队列没有容量，因此不能调用peek操作，因为只有移除元素时才有元素。显然这是一种快速传递元素的方式，也就是说在这种情况下元素总是以最快的方式从插入者（生产者）传递给移除者（消费者），这在多任务队列中是最快处理任务的方式。对于高频繁请求的场景，无疑是最适合的。<br>异步执行是通过Call.enqueue(Callback responseCallback)来执行，在Dispatcher中添加一个封装了Callback的Call的匿名内部类Runnable来执行当前的Call。这里一定要注意的地方这个AsyncCall是Call的匿名内部类。AsyncCall的execute方法仍然会回调到Call的getResponseWithInterceptorChain方法来完成请求，同时将返回数据或者状态通过Callback来完成。</li>
</ul>
</blockquote>
<p>接下来继续讲讲Call的getResponseWithInterceptorChain（）方法，这里边重点说一下拦截器链条的实现以及作用。</p>
<p>##拦截器有什么作用<br>先来看看Interceptor本身的文档解释：观察，修改以及可能短路的请求输出和响应请求的回来。通常情况下拦截器用来添加，移除或者转换请求或者回应的头部信息。<br>拦截器接口中有intercept(Chain chain)方法，同时返回Response。所谓拦截器更像是AOP设计的一种实现。下面来看一个okhttp源码中的一个引导例子来说明拦截器的作用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public final class LoggingInterceptors &#123;</span><br><span class="line">  private static final Logger logger = Logger.getLogger(LoggingInterceptors.class.getName());</span><br><span class="line">  private final OkHttpClient client = new OkHttpClient();</span><br><span class="line"></span><br><span class="line">  public LoggingInterceptors() &#123;</span><br><span class="line">    client.networkInterceptors().add(new Interceptor() &#123;</span><br><span class="line">      @Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">        long t1 = System.nanoTime();</span><br><span class="line">        Request request = chain.request();</span><br><span class="line">        logger.info(String.format(&quot;Sending request %s on %s%n%s&quot;,</span><br><span class="line">            request.url(), chain.connection(), request.headers()));</span><br><span class="line">        Response response = chain.proceed(request);</span><br><span class="line"></span><br><span class="line">        long t2 = System.nanoTime();</span><br><span class="line">        logger.info(String.format(&quot;Received response for %s in %.1fms%n%s&quot;,</span><br><span class="line">            request.url(), (t2 - t1) / 1e6d, response.headers()));</span><br><span class="line">        return response;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void run() throws Exception &#123;</span><br><span class="line">    Request request = new Request.Builder()</span><br><span class="line">        .url(&quot;https://publicobject.com/helloworld.txt&quot;)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    Response response = client.newCall(request).execute();</span><br><span class="line">    response.body().close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main(String... args) throws Exception &#123;</span><br><span class="line">    new LoggingInterceptors().run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>返回信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">三月 19, 2015 2:11:29 下午 com.squareup.okhttp.recipes.LoggingInterceptors$1 intercept</span><br><span class="line">信息: Sending request https://publicobject.com/helloworld.txt on Connection&#123;publicobject.com:443, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA protocol=http/1.1&#125;</span><br><span class="line">Host: publicobject.com </span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Accept-Encoding: gzip</span><br><span class="line">User-Agent: </span><br><span class="line"></span><br><span class="line">三月 19, 2015 2:11:30 下午 com.squareup.okhttp.recipes.LoggingInterceptors$1 intercept</span><br><span class="line">信息: Received response for https://publicobject.com/helloworld.txt in 275.9ms</span><br><span class="line">Server: nginx/1.4.6 (Ubuntu)</span><br><span class="line">Date: Thu, 19 Mar 2015 06:08:50 GMT</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 1759</span><br><span class="line">Last-Modified: Tue, 27 May 2014 02:35:47 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line">ETag: &quot;5383fa03-6df&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">OkHttp-Selected-Protocol: http/1.1</span><br><span class="line">OkHttp-Sent-Millis: 1426745489953</span><br><span class="line">OkHttp-Received-Millis: 1426745490198</span><br></pre></td></tr></table></figure></p>
<p>从这里的执行来看，拦截器主要是针对Request和Response的切面处理。<br>那再来看看源码到底在什么位置做的这个处理呢？为了更加直观的反应执行流程，本人截图了一下执行堆栈<br><img src="http://frodoking.github.io/img/android/okhttp_interceptor_running_stack.png" alt="OKHttp总体设计图"><br>另外如果还有同学对Interceptor比较敢兴趣的可以去源码的simples模块看看GzipRequestInterceptor.java针对HTTP request body的一个zip压缩。</p>
<p>在这里再多说一下关于Call这个类的作用，在Call中持有一个HttpEngine。每一个不同的Call都有自己独立的HttpEngine。在HttpEngine中主要是各种链路和地址的选择，还有一个Transport比较重要</p>
<p>##缓存策略<br>在OkHttpClient内部暴露了有Cache和InternalCache。而InternalCache不应该手动去创建，所以作为开发使用者来说，一般用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public final class CacheResponse &#123;</span><br><span class="line">  private static final Logger logger = Logger.getLogger(LoggingInterceptors.class.getName());</span><br><span class="line">  private final OkHttpClient client;</span><br><span class="line"></span><br><span class="line">  public CacheResponse(File cacheDirectory) throws Exception &#123;</span><br><span class="line">    logger.info(String.format(&quot;Cache file path %s&quot;,cacheDirectory.getAbsoluteFile()));</span><br><span class="line">    int cacheSize = 10 * 1024 * 1024; // 10 MiB</span><br><span class="line">    Cache cache = new Cache(cacheDirectory, cacheSize);</span><br><span class="line"></span><br><span class="line">    client = new OkHttpClient();</span><br><span class="line">    client.setCache(cache);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public void run() throws Exception &#123;</span><br><span class="line">    Request request = new Request.Builder()</span><br><span class="line">        .url(&quot;http://publicobject.com/helloworld.txt&quot;)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    Response response1 = client.newCall(request).execute();</span><br><span class="line">    if (!response1.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response1);</span><br><span class="line"></span><br><span class="line">    String response1Body = response1.body().string();</span><br><span class="line">    System.out.println(&quot;Response 1 response:          &quot; + response1);</span><br><span class="line">    System.out.println(&quot;Response 1 cache response:    &quot; + response1.cacheResponse());</span><br><span class="line">    System.out.println(&quot;Response 1 network response:  &quot; + response1.networkResponse());</span><br><span class="line"></span><br><span class="line">    Response response2 = client.newCall(request).execute();</span><br><span class="line">    if (!response2.isSuccessful()) throw new IOException(&quot;Unexpected code &quot; + response2);</span><br><span class="line"></span><br><span class="line">    String response2Body = response2.body().string();</span><br><span class="line">    System.out.println(&quot;Response 2 response:          &quot; + response2);</span><br><span class="line">    System.out.println(&quot;Response 2 cache response:    &quot; + response2.cacheResponse());</span><br><span class="line">    System.out.println(&quot;Response 2 network response:  &quot; + response2.networkResponse());</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;Response 2 equals Response 1? &quot; + response1Body.equals(response2Body));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public static void main(String... args) throws Exception &#123;</span><br><span class="line">    new CacheResponse(new File(&quot;CacheResponse.tmp&quot;)).run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>返回信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">信息: Cache file path D:\work\workspaces\workspaces_intellij\workspace_opensource\okhttp\CacheResponse.tmp</span><br><span class="line">Response 1 response:          Response&#123;protocol=http/1.1, code=200, message=OK, url=https://publicobject.com/helloworld.txt&#125;</span><br><span class="line">Response 1 cache response:    null</span><br><span class="line">Response 1 network response:  Response&#123;protocol=http/1.1, code=200, message=OK, url=https://publicobject.com/helloworld.txt&#125;</span><br><span class="line">Response 2 response:          Response&#123;protocol=http/1.1, code=200, message=OK, url=https://publicobject.com/helloworld.txt&#125;</span><br><span class="line">Response 2 cache response:    Response&#123;protocol=http/1.1, code=200, message=OK, url=https://publicobject.com/helloworld.txt&#125;</span><br><span class="line">Response 2 network response:  null</span><br><span class="line">Response 2 equals Response 1? true</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></p>
<p>上边这一段代码同样来之于simple代码CacheResponse.java，反馈回来的数据重点看一下缓存日志。第一次是来至网络数据，第二次来至缓存。<br>那在这一节重点说一下整个框架的缓存策略如何实现的。 </p>
<p>在这里继续使用上一节中讲到的运行堆栈图。从Call.getResponse(Request request, boolean forWebSocket)执行Engine.sendRequest()和Engine.readResponse()来详细说明一下。</p>
<p><strong>sendRequest()</strong><br>此方法是对可能的Response资源进行一个预判，如果需要就会开启一个socket来获取资源。如果请求存在那么就会为当前request添加请求头部并且准备开始写入request body。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public void sendRequest() throws IOException &#123;</span><br><span class="line">        if (cacheStrategy != null) &#123;</span><br><span class="line">            return; // Already sent.</span><br><span class="line">        &#125;</span><br><span class="line">        if (transport != null) &#123;</span><br><span class="line">            throw new IllegalStateException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //填充默认的请求头部和事务。</span><br><span class="line">        Request request = networkRequest(userRequest);</span><br><span class="line"></span><br><span class="line">        //下面一行很重要,这个方法会去获取client中的Cache。同时Cache在初始化的时候会去读取缓存目录中关于曾经请求过的所有信息。</span><br><span class="line">        InternalCache responseCache = Internal.instance.internalCache(client);</span><br><span class="line">        Response cacheCandidate = responseCache != null? responseCache.get(request): null;</span><br><span class="line"></span><br><span class="line">        long now = System.currentTimeMillis();</span><br><span class="line">        //缓存策略中的各种配置的封装</span><br><span class="line">        cacheStrategy = new CacheStrategy.Factory(now, request, cacheCandidate).get();</span><br><span class="line">        networkRequest = cacheStrategy.networkRequest;</span><br><span class="line">        cacheResponse = cacheStrategy.cacheResponse;</span><br><span class="line"></span><br><span class="line">        if (responseCache != null) &#123;</span><br><span class="line">            //记录当前请求是来至网络还是命中了缓存</span><br><span class="line">            responseCache.trackResponse(cacheStrategy);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">            closeQuietly(cacheCandidate.body()); // The cache candidate wasn&apos;t applicable. Close it.</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (networkRequest != null) &#123;</span><br><span class="line">            // Open a connection unless we inherited one from a redirect.</span><br><span class="line">            if (connection == null) &#123;</span><br><span class="line">                //连接到服务器、重定向服务器或者通过一个代理Connect to the origin server either directly or via a proxy.</span><br><span class="line">                connect();</span><br><span class="line">            &#125;</span><br><span class="line">            //通过Connection创建一个SpdyTransport或者HttpTransport</span><br><span class="line">            transport = Internal.instance.newTransport(connection, this);</span><br><span class="line">            ...</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>readResponse()</strong><br>此方法发起刷新请求头部和请求体，解析HTTP回应头部，并且如果HTTP回应体存在的话就开始读取当前回应头。在这里有发起返回存入缓存系统，也有返回和缓存系统进行一个对比的过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public void readResponse() throws IOException &#123;</span><br><span class="line">        ...</span><br><span class="line">        Response networkResponse;</span><br><span class="line"></span><br><span class="line">        if (forWebSocket) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; else if (!callerWritesRequestBody) &#123;</span><br><span class="line">            // 这里主要是看当前的请求body，其实真正请求是在这里发生的。</span><br><span class="line">            // 在readNetworkResponse()方法中执行transport.finishRequest()</span><br><span class="line">            // 这里可以看一下该方法内部会调用到HttpConnection.flush()方法</span><br><span class="line">            networkResponse = new NetworkInterceptorChain(0, networkRequest).proceed(networkRequest);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">		//对Response头部事务存入事务管理中</span><br><span class="line">        receiveHeaders(networkResponse.headers());</span><br><span class="line"></span><br><span class="line">        // If we have a cache response too, then we&apos;re doing a conditional get.</span><br><span class="line">        if (cacheResponse != null) &#123;</span><br><span class="line">			//检查缓存是否可用，如果可用。那么就用当前缓存的Response，关闭网络连接，释放连接。</span><br><span class="line">            if (validate(cacheResponse, networkResponse)) &#123;</span><br><span class="line">                userResponse = cacheResponse.newBuilder()</span><br><span class="line">                        .request(userRequest)</span><br><span class="line">                        .priorResponse(stripBody(priorResponse))</span><br><span class="line">                        .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">                        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">                        .networkResponse(stripBody(networkResponse))</span><br><span class="line">                        .build();</span><br><span class="line">                networkResponse.body().close();</span><br><span class="line">                releaseConnection();</span><br><span class="line"></span><br><span class="line">                // Update the cache after combining headers but before stripping the</span><br><span class="line">                // Content-Encoding header (as performed by initContentStream()).</span><br><span class="line">				// 更新缓存以及缓存命中情况</span><br><span class="line">                InternalCache responseCache = Internal.instance.internalCache(client);</span><br><span class="line">                responseCache.trackConditionalCacheHit();</span><br><span class="line">                responseCache.update(cacheResponse, stripBody(userResponse));</span><br><span class="line">				// unzip解压缩response</span><br><span class="line">                userResponse = unzip(userResponse);</span><br><span class="line">                return;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                closeQuietly(cacheResponse.body());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        userResponse = networkResponse.newBuilder()</span><br><span class="line">                .request(userRequest)</span><br><span class="line">                .priorResponse(stripBody(priorResponse))</span><br><span class="line">                .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">                .networkResponse(stripBody(networkResponse))</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        //发起缓存的地方</span><br><span class="line">        if (hasBody(userResponse)) &#123;</span><br><span class="line">            maybeCache();</span><br><span class="line">            userResponse = unzip(cacheWritingResponse(storeRequest, userResponse));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>##HTTP连接的实现方式（说说连接池）<br>外部网络请求的入口都是通过Transport接口来完成。该类采用了桥接模式将HttpEngine和HttpConnection来连接起来。因为HttpEngine只是一个逻辑处理器，同时它也充当了请求配置的提供引擎，而HttpConnection是对底层处理Connection的封装。</p>
<p>OK现在重点转移到HttpConnection（一个用于发送HTTP/1.1信息的socket连接）这里。主要有如下的生命周期：</p>
<blockquote>
<p>1、发送请求头；<br>2、打开一个sink(io中有固定长度的或者块结构chunked方式的)去写入请求body；<br>3、写入并且关闭sink；<br>4、读取Response头部；<br>5、打开一个source（对应到第2步的sink方式）去读取Response的body；<br>6、读取并关闭source；</p>
</blockquote>
<p>下边看一张关于连接执行的时序图：<br><img src="http://frodoking.github.io/img/android/okhttp_connection_lifecycle.png" alt="OKHttp连接执行时序图"><br>这张图画得比较简单，详细的过程以及连接池的使用下面大致说明一下：</p>
<blockquote>
<p>1、连接池是暴露在client下的，它贯穿了Transport、HttpEngine、Connection、HttpConnection和SpdyConnection；在这里目前默认讨论HttpConnection；<br>2、ConnectionPool有两个构建参数是maxIdleConnections（最大空闲连接数）和keepAliveDurationNs（存活时间）,另外连接池默认的线程池采用了Single的模式（源码解释是：一个用于清理过期的多个连接的后台线程，最多一个单线程去运行每一个连接池）；<br>3、发起请求是在Connection.connect()这里，实际执行是在HttpConnection.flush()这里进行一个刷入。这里重点应该关注一下sink和source，他们创建的默认方式都是依托于同一个socket：<br>    this.source = Okio.buffer(Okio.source(socket));<br>    this.sink = Okio.buffer(Okio.sink(socket));<br>    如果再进一步看一下io的源码就能看到：<br>    Source source = source((InputStream)socket.getInputStream(), (Timeout)timeout);<br>    Sink sink = sink((OutputStream)socket.getOutputStream(), (Timeout)timeout);<br>    这下我想大家都应该明白这里到底是真么回事儿了吧？<br>    相关的sink和source还有相应的细分，如果有兴趣的朋友可以继续深入看一下，这里就不再深入了。不然真的说不完了。。。</p>
</blockquote>
<p>其实连接池这里还是有很多值得细看的地方，由于时间有限，到这里已经花了很多时间搞这事儿了。。。</p>
<p>##重连机制<br>这里重点说说连接链路的相关事情。说说自动重连到底是如何实现的。<br>照样先来看看下面的这个自动重连机制的实现方式时序图<br><img src="http://frodoking.github.io/img/android/okhttp_connection_reset.png" alt="OKHttp重连执行时序图"></p>
<p>同时回到Call.getResponse()方法说起<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Response getResponse(Request request, boolean forWebSocket) throws IOException &#123;</span><br><span class="line">    ...</span><br><span class="line">    while (true) &#123; // 自动重连机制的循环处理</span><br><span class="line">      if (canceled) &#123;</span><br><span class="line">        engine.releaseConnection();</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">        engine.sendRequest();</span><br><span class="line">        engine.readResponse();</span><br><span class="line">      &#125; catch (IOException e) &#123;</span><br><span class="line">		//如果上一次连接异常，那么当前连接进行一个恢复。</span><br><span class="line">        HttpEngine retryEngine = engine.recover(e, null);</span><br><span class="line">        if (retryEngine != null) &#123;</span><br><span class="line">          engine = retryEngine;</span><br><span class="line">          continue;//如果恢复成功，那么继续重新请求</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Give up; recovery is not possible.如果不行，那么就中断了</span><br><span class="line">        throw e;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Response response = engine.getResponse();</span><br><span class="line">      Request followUp = engine.followUpRequest();</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>相信这一段代码能让同学们清晰的看到自动重连机制的实现方式，那么我们来看看详细的步骤：</p>
<blockquote>
<p>1、HttpEngine.recover()的实现方式是通过检测RouteSelector是否还有更多的routes可以尝试连接，同时会去检查是否可以恢复等等的一系列判断。如果可以会为重新连接重新创建一份新的HttpEngine，同时把相应的链路信息传递过去；<br>2、当恢复后的HttpEngine不为空，那么替换当前Call中的当前HttpEngine，执行while的continue，发起下一次的请求；<br>3、再重点强调一点HttpEngine.sendRequest()。这里之前分析过会触发connect()方法，在该方法中会通过RouteSelector.next()再去找当前适合的Route。多说一点，next()方法会传递到nextInetSocketAddress()方法，而此处一段重要的执行代码就是network.resolveInetAddresses(socketHost)。这个地方最重要的是在Network这个接口中有一个对该接口的DEFAULT的实现域，而该方法通过工具类InetAddress.getAllByName(host)来完成对数组类的地址解析。<br>   所以，多地址可以采用[“<a href="http://aaaaa&quot;,&quot;https://bbbbbb&quot;]的方式来配置。" target="_blank" rel="external">http://aaaaa&quot;,&quot;https://bbbbbb&quot;]的方式来配置。</a></p>
</blockquote>
<p>##Gzip的使用方式<br>在源码引导RequestBodyCompression.java中我们可以看到gzip的使用身影。通过拦截器对Request 的body进行gzip的压缩，来减少流量的传输。<br>Gzip实现的方式主要是通过GzipSink对普通sink的封装压缩。在这个地方就不再贴相关代码的实现。有兴趣同学对照源码看一下就ok。</p>
<p>强大的Interceptor设计应该也算是这个框架的一个亮点。</p>
<p>##安全性<br>连接安全性主要是在HttpEngine.connect()方法。上一节油讲到地址相关的选择，在HttpEngine中有一个静态方法createAddress(client, networkRequest)，在这里通过获取到OkHttpClient中关于SSLSocketFactory、HostnameVerifier和CertificatePinner的配置信息。而这些信息大部分采用默认情况。这些信息都会在后面的重连中作为对比参考项。</p>
<p>同时在Connection.upgradeToTls()方法中，有对SSLSocket、SSLSocketFactory的创建活动。这些创建都会被记录到ConnectionSpec中,当发起ConnectionSpec.apply()会发起一些列的配置以及验证。</p>
<p>建议有兴趣的同学先了解java的SSLSocket相关的开发再来了解本框架中的安全性，会更能理解一些。</p>
<p>##平台适应性<br>讲了很多，终于来到了平台适应性了。Platform是整个平台适应的核心类。同时它封装了针对不同平台的三个平台类Android和JdkWithJettyBootPlatform。<br>代码实现在Platform.findPlatform中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">private static Platform findPlatform() &#123;</span><br><span class="line">    // Attempt to find Android 2.3+ APIs.</span><br><span class="line">    try &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        Class.forName(&quot;com.android.org.conscrypt.OpenSSLSocketImpl&quot;);</span><br><span class="line">      &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">        // Older platform before being unbundled.</span><br><span class="line">        Class.forName(&quot;org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      OptionalMethod&lt;Socket&gt; setUseSessionTickets</span><br><span class="line">          = new OptionalMethod&lt;&gt;(null, &quot;setUseSessionTickets&quot;, boolean.class);</span><br><span class="line">      OptionalMethod&lt;Socket&gt; setHostname</span><br><span class="line">          = new OptionalMethod&lt;&gt;(null, &quot;setHostname&quot;, String.class);</span><br><span class="line">      Method trafficStatsTagSocket = null;</span><br><span class="line">      Method trafficStatsUntagSocket = null;</span><br><span class="line">      OptionalMethod&lt;Socket&gt; getAlpnSelectedProtocol = null;</span><br><span class="line">      OptionalMethod&lt;Socket&gt; setAlpnProtocols = null;</span><br><span class="line"></span><br><span class="line">      // Attempt to find Android 4.0+ APIs.</span><br><span class="line">      try &#123;</span><br><span class="line">	  //流浪统计类</span><br><span class="line">        Class&lt;?&gt; trafficStats = Class.forName(&quot;android.net.TrafficStats&quot;);</span><br><span class="line">        trafficStatsTagSocket = trafficStats.getMethod(&quot;tagSocket&quot;, Socket.class);</span><br><span class="line">        trafficStatsUntagSocket = trafficStats.getMethod(&quot;untagSocket&quot;, Socket.class);</span><br><span class="line"></span><br><span class="line">        // Attempt to find Android 5.0+ APIs.</span><br><span class="line">        try &#123;</span><br><span class="line">          Class.forName(&quot;android.net.Network&quot;); // Arbitrary class added in Android 5.0.</span><br><span class="line">          getAlpnSelectedProtocol = new OptionalMethod&lt;&gt;(byte[].class, &quot;getAlpnSelectedProtocol&quot;);</span><br><span class="line">          setAlpnProtocols = new OptionalMethod&lt;&gt;(null, &quot;setAlpnProtocols&quot;, byte[].class);</span><br><span class="line">        &#125; catch (ClassNotFoundException ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch (ClassNotFoundException | NoSuchMethodException ignored) &#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return new Android(setUseSessionTickets, setHostname, trafficStatsTagSocket,</span><br><span class="line">          trafficStatsUntagSocket, getAlpnSelectedProtocol, setAlpnProtocols);</span><br><span class="line">    &#125; catch (ClassNotFoundException ignored) &#123;</span><br><span class="line">      // This isn&apos;t an Android runtime.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Find Jetty&apos;s ALPN extension for OpenJDK.</span><br><span class="line">    try &#123;</span><br><span class="line">      String negoClassName = &quot;org.eclipse.jetty.alpn.ALPN&quot;;</span><br><span class="line">      Class&lt;?&gt; negoClass = Class.forName(negoClassName);</span><br><span class="line">      Class&lt;?&gt; providerClass = Class.forName(negoClassName + &quot;$Provider&quot;);</span><br><span class="line">      Class&lt;?&gt; clientProviderClass = Class.forName(negoClassName + &quot;$ClientProvider&quot;);</span><br><span class="line">      Class&lt;?&gt; serverProviderClass = Class.forName(negoClassName + &quot;$ServerProvider&quot;);</span><br><span class="line">      Method putMethod = negoClass.getMethod(&quot;put&quot;, SSLSocket.class, providerClass);</span><br><span class="line">      Method getMethod = negoClass.getMethod(&quot;get&quot;, SSLSocket.class);</span><br><span class="line">      Method removeMethod = negoClass.getMethod(&quot;remove&quot;, SSLSocket.class);</span><br><span class="line">      return new JdkWithJettyBootPlatform(</span><br><span class="line">          putMethod, getMethod, removeMethod, clientProviderClass, serverProviderClass);</span><br><span class="line">    &#125; catch (ClassNotFoundException | NoSuchMethodException ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new Platform();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里采用了JAVA的反射原理调用到class的method。最后在各自的平台调用下发起invoke来执行相应方法。详情请参看继承了Platform的Android类。<br>当然要做这两种的平台适应，必须要知道当前平台在内存中相关的class地址以及相关方法。</p>
<p>##总结<br>1、从整体结构和类内部域中都可以看到OkHttpClient，有点类似与安卓的ApplicationContext。看起来更像一个单例的类，这样使用好处是统一。但是如果你不是高手，建议别这么用，原因很简单：逻辑牵连太深，如果出现问题要去追踪你会有深深地罪恶感的；<br>2、框架中的一些动态方法、静态方法、匿名内部类以及Internal的这些代码相当规整，每个不同类的不同功能能划分在不同的地方。很值得开发者学习的地方；<br>3、从平台的兼容性来讲，也是很不错的典范（如果你以后要从事API相关编码，那更得好好注意对兼容性的处理）；<br>4、由于时间不是很富裕，所以本人对细节的把握还是不够，这方面还得多多努力；<br>5、对于初学网络编程的同学来说，可能一开始学习都是从简单的socket的发起然后获取响应开始的。因为没有很好的场景能让自己知道网络编程到底有多么的重要，当然估计也没感受到网络编程有多么的难受。我想这是很多刚入行的同学们的一种内心痛苦之处；<br>6、不足的地方是没有对SPDY的方式最详细跟进剖析（手头还有工作的事情，后面如果有时间再补起来吧）。</p>
<p>##结束语<br>很早前都打算花点时间好好来看一个值得学习的框架，今天终于算是弄得差不多了。我相信从框架的前期使用、到代码的介入、再到源码分模块的剖析、最后到整理成文章。我想这都是一个很好的学习和成长的过程。</p>
<p>希望看到这篇文章的同学能做出评价，并且给出一些好的剖析点。</p>
<p>我也是一个普普通通的编码人，只是内心多了一点点不“安分” ^.^。</p>
<p>##后续<br>最近看到一些网友建议把okhttp的连接池对Connection的重用维护机制以及HTTP和SPDY协议如何得到区分这两部分内容做深入的分析<br>有需要的同学请移步：<a href="/2015/06/29/android-okhttp-connectionpool-http1-x-http2-x/">OKHttp源码解析-ConnectionPool对Connection重用机制&amp;Http/Https/SPDY协议选择</a></p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/03/19/life-the-fucking-youth/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          狗日的青春-贰佰
        
      </div>
    </a>
  
  
    <a href="/2015/02/10/android-dependency-injection-struction/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">依赖注入思路以及如何选择（Dagger、RoboGuice和ButterKnife）</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="android-okhttp" data-title="OKHttp源码解析" data-url="http://frodoking.github.io/2015/03/12/android-okhttp/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Frodo
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>